// რანდომულად შევარჩიოთ სტრიქონების და სვეტების რაოდენობა 0-იდან 10-ის ჩათვლით.
let row = Math.round(Math.random() * 10) + 1;
let col = Math.round(Math.random() * 10) + 1;

// მთავარი ფუნქცია
const getTable = (row, col) => {

    // შევქმნათ output მასივი სტრიქონების რაოდენობის ზომის.
    let output = new Array(row);

    // შევავსოთ output მასივი, სვეტების რაოდენობის ზომის მასივებით. 
    for(let i = 0; i < row; i++){
        output[i] = new Array(col);
    }

    // შევქმნათ ცვლადი რომლის მნიშვნელობებითაც შევავსებთ მასივებს.
    let count = 1;
    
    // შევავსოთ მასივი უკუღმად სვეტების მიხედვით.
    for(let i_col = 0; i_col < col; i_col++){

        for(let i_row = 0; i_row < row; i_row++){
            /*
            ჩავწეროთ ცვლადის მნიშვნელობა i_row სტრიქონზე არსებული მასივის i_col ინდექსზე,
            გადავიდეთ შემდეგ სტრიქონზე.
            */
            output[i_row][i_col] = count++; // თითო შევსების შემდეგ ცვლადი გავზარდოთ post-increment-ით.
        }

        /*
        როდესაც მიმდინარე ვერტიკალს(მიმდინარე სვეტზე არსებულ ინდექსებს) შევავსებთ, გადავიდეთ შემდეგ ვერტიკალზე
        და შემოვიტანოთ სვეტების ამოწურვის შემოწმების პირობა, for ციკლში გაწერილი პირობის მსგავსად.
        */
        i_col++;
        if(i_col == col){
            break;
        }

        else{

            // თითო მომდევნო ვერტიკალი შევავსოთ ქვევიდან ზევით დავალების ლოგიკის მიხედვით.
            for(i_row = (row - 1); i_row >= 0; i_row--){
                /*
                i_row სტრიქონების იტერატორი გადავაკეთეთ უკუღმა იტერატორად:
                გავუტოლეთ output მასივის ბოლო index-ს და თითო ციკლის ლოგიკის შესრულების შემდეგ შევამცირებთ,
                რაც მოგვცემს საშუალებას შევავსოთ ვერტიკალი ქვევიდან ზევით.
                */
                output[i_row][i_col] = count++;
            }
        }

        // ამ loop-ის ყოველ ციკლზე ივსება თითო ორი ვერტიკალი, ზევიდან ქვევით და მომდევნო ქვევიდან ზევით.
    }
    
    // დავაბრუნოთ დასრულებული მატრიცა.
    return output;
}

console.log(getTable(row, col))
return;